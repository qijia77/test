<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç§‘å¹»ç²’å­åœº V6 (CNPMJS æœ€ç»ˆä¿®å¤ç‰ˆ)</title>
    
    <script src="https://cdn.cnpmjs.org/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.cnpmjs.org/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.cnpmjs.org/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #000; overflow: hidden; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center;}
        
        #input_video { display: none; }
        
        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            display: block;
        }

        .loading {
            position: absolute;
            color: rgba(0, 255, 255, 0.7); 
            font-family: 'Consolas', monospace;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 10;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="loading" id="loadingText">
        ğŸ‘‹ **æ¨¡å‹åŠ è½½ä¸­...** (å·²ä¿®å¤é•œåƒï¼Œè¯·è€å¿ƒç­‰å¾…)<br>
        <hr style="margin: 10px 0; border-color: rgba(0, 255, 255, 0.3);">
        **æ“ä½œæç¤º:** è¯·ç¡®ä¿æ‘„åƒå¤´æƒé™å·²å…è®¸ã€‚
    </div>
    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingText = document.getElementById('loadingText');

    let canvasWidth = window.innerWidth;
    let canvasHeight = window.innerHeight;
    canvasElement.width = canvasWidth;
    canvasElement.height = canvasHeight;

    // --- å…¨å±€å¸¸é‡ ---
    const centerPoint = { x: canvasWidth / 2, y: canvasHeight / 2 };
    const MAX_PARTICLES = 800; 
    const MIN_DISTANCE_CONNECT = 80; 
    
    // --- çŠ¶æ€å˜é‡ ---
    let currentForceFactor = 0.0; 
    let fingerTipPoint = null; 
    
    // --- ç²’å­ç±» (ä¿æŒä¸å˜) ---
    class Particle {
        constructor() {
            this.resetPosition(true);
            this.size = Math.random() * 1.5 + 0.5; 
            this.color = Math.random() * 30 + 190; 
            this.alpha = 0.8; 
            this.friction = 0.96; 
            this.speedFactor = 1.5;
            this.BASE_FORCE = 0.005; 
        }

        update() {
            let dx = centerPoint.x - this.x;
            let dy = centerPoint.y - this.y;
            let distanceSq = dx * dx + dy * dy;
            let fieldForce = currentForceFactor * 1000000 / (distanceSq + 50000); 

            if (fingerTipPoint) {
                let fdx = fingerTipPoint.x - this.x;
                let fdy = fingerTipPoint.y - this.y;
                let fDistanceSq = fdx * fdx + fdy * fdy;
                const FINGER_ATTRACTION = 800000; 
                let localForce = FINGER_ATTRACTION / (fDistanceSq + 20000); 

                let fAngle = Math.atan2(fdy, fdx);
                this.vx += localForce * Math.cos(fAngle);
                this.vy += localForce * Math.sin(fAngle);
            }
            
            let randomForceX = (Math.random() - 0.5) * this.BASE_FORCE;
            let randomForceY = (Math.random() - 0.5) * this.BASE_FORCE;
            let angle = Math.atan2(dy, dx);
            
            this.vx += fieldForce * Math.cos(angle) + randomForceX;
            this.vy += fieldForce * Math.sin(angle) + randomForceY;
            
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= this.friction;
            this.vy *= this.friction;

            if (this.x < -10 || this.x > canvasWidth + 10 || this.y < -10 || this.y > canvasHeight + 10) {
                 this.resetPosition();
            }
        }
        
        resetPosition(isInitial = false) {
            const side = Math.floor(Math.random() * 4); 
            const speedFactor = this.speedFactor;

            if (side === 0) {
                this.x = Math.random() * canvasWidth;
                this.y = -10;
            } else if (side === 1) { 
                this.x = Math.random() * canvasWidth;
                this.y = canvasHeight + 10;
            } else if (side === 2) { 
                this.x = -10;
                this.y = Math.random() * canvasHeight;
            } else { 
                this.x = canvasWidth + 10;
                this.y = Math.random() * canvasHeight;
            }
            
            if (isInitial) {
                this.vx = (Math.random() - 0.5) * speedFactor;
                this.vy = (Math.random() - 0.5) * speedFactor;
            } else {
                this.vx = (centerPoint.x - this.x) * 0.005 + (Math.random() - 0.5) * speedFactor;
                this.vy = (centerPoint.y - this.y) * 0.005 + (Math.random() - 0.5) * speedFactor;
            }
        }

        draw() {
            canvasCtx.fillStyle = `hsla(${this.color}, 100%, 60%, ${this.alpha})`;
            canvasCtx.beginPath();
            canvasCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            canvasCtx.fill();
        }
    }

    // åˆå§‹åŒ–ç²’å­æ± 
    let particlesArray = [];
    function initParticles() {
        for (let i = 0; i < MAX_PARTICLES; i++) {
            particlesArray.push(new Particle());
        }
    }
    initParticles();
    
    // ç²’å­è¿æ¥é€»è¾‘
    function connectParticles() {
        let opacity = 1;
        for (let i = 0; i < particlesArray.length; i++) {
            for (let j = i; j < particlesArray.length; j++) {
                let dx = particlesArray[i].x - particlesArray[j].x;
                let dy = particlesArray[i].y - particlesArray[j].y;
                let distanceSq = dx * dx + dy * dy;
                
                if (distanceSq < MIN_DISTANCE_CONNECT * MIN_DISTANCE_CONNECT) {
                    opacity = 1 - (Math.sqrt(distanceSq) / MIN_DISTANCE_CONNECT);
                    
                    canvasCtx.strokeStyle = `rgba(0, 200, 255, ${opacity * 0.4})`;
                    canvasCtx.lineWidth = 0.5;
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(particlesArray[i].x, particlesArray[i].y);
                    canvasCtx.lineTo(particlesArray[j].x, particlesArray[j].y);
                    canvasCtx.stroke();
                }
            }
        }
    }


    // --- MediaPipe åˆå§‹åŒ–è®¾å®š (æ ¸å¿ƒä¿®æ­£ 2ï¼šä½¿ç”¨æ­£ç¡®çš„ CNPMJS é•œåƒ) ---
    const HANDS_URL_STABLE = "https://cdn.cnpmjs.org/@mediapipe/hands";

    const hands = new Hands({locateFile: (file) => {
        return `${HANDS_URL_STABLE}/${file}`; // ä½¿ç”¨æ­£ç¡®çš„ CNPMJS é•œåƒåŠ è½½æ¨¡å‹
    }});
    hands.setOptions({
        maxNumHands: 1, 
        modelComplexity: 0, 
        minDetectionConfidence: 0.5, 
        minTrackingConfidence: 0.5
    });

    // æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
    function detectGesture(landmarks) {
        let foldedFingers = 0;
        const TIP_INDEXES = [8, 12, 16, 20];
        const MCP_INDEXES = [5, 9, 13, 17];
        
        for (let i = 0; i < 4; i++) {
            if (landmarks[TIP_INDEXES[i]].y > landmarks[MCP_INDEXES[i]].y) {
                foldedFingers++;
            }
        }
        return foldedFingers >= 3 ? 'gather' : 'scatter';
    }


    // MediaPipe ç»“æœå›è°ƒå‡½æ•°
    function onResults(results) {
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);
        
        let targetFactor = 0.0; 
        fingerTipPoint = null;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            loadingText.style.display = 'none'; 
            const landmarks = results.multiHandLandmarks[0];

            fingerTipPoint = {
                x: landmarks[8].x * canvasWidth,
                y: landmarks[8].y * canvasHeight
            };

            const gesture = detectGesture(landmarks);
            
            if (gesture === 'gather') {
                targetFactor = 0.75; 
            } else if (gesture === 'scatter') {
                targetFactor = -1.5; 
            }
        } else {
             targetFactor = 0.0;
             loadingText.style.display = 'block'; 
        }

        currentForceFactor += (targetFactor - currentForceFactor) * 0.1;
        
        connectParticles();

        for (let i = 0; i < particlesArray.length; i++) {
            particlesArray[i].update();
            particlesArray[i].draw();
        }
        
        requestAnimationFrame(() => hands.send({image: videoElement}));
    }

    // --- å¯åŠ¨æ‘„åƒå¤´ (å¢å¼ºé”™è¯¯æ•è·) ---
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement}); 
        },
        width: 640, 
        height: 480,
        facingMode: 'user'
    });
    camera.start().catch(err => {
        // å¢å¼ºé”™è¯¯æç¤º
        loadingText.innerHTML = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼<br>è¯·ç¡®ä¿åœ¨ HTTPS ç¯å¢ƒä¸­è¿è¡Œï¼Œå¹¶æ‰‹åŠ¨æ£€æŸ¥æµè§ˆå™¨/ç³»ç»Ÿè®¾ç½®æ˜¯å¦å…è®¸æ‘„åƒå¤´æƒé™ã€‚";
        console.error("Camera start failed:", err);
    });

    // çª—å£å¤§å°æ”¹å˜é€‚åº”
    window.addEventListener('resize', () => {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        canvasElement.width = canvasWidth;
        canvasElement.height = canvasHeight;
        centerPoint.x = canvasWidth / 2;
        centerPoint.y = canvasHeight / 2;
    });

</script>
</body>
</html>
