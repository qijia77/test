<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­åœº V7 (è¯Šæ–­æ¨¡å¼)</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #000; overflow: hidden; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center;}
        
        #input_video { display: none; }
        
        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); 
            display: block;
        }

        /* è°ƒè¯•æ§åˆ¶å°æ ·å¼ */
        #debug_console {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            max-height: 50%;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            padding: 10px;
            z-index: 100;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */
        }
        .error { color: #ff3333; font-weight: bold; }
        .success { color: #33ff33; }
        .info { color: #aaa; }
    </style>

    <script>
        function log(msg, type='info') {
            const consoleDiv = document.getElementById('debug_console');
            if(consoleDiv) {
                const p = document.createElement('div');
                p.className = type;
                p.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
                consoleDiv.appendChild(p);
                consoleDiv.scrollTop = consoleDiv.scrollHeight; // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            }
            console.log(msg);
        }
        window.onerror = function(msg, url, line) {
            log(`å…¨å±€é”™è¯¯: ${msg} (Line: ${line})`, 'error');
        };
    </script>
</head>
<body>
    <div id="debug_console">
        <div>ğŸš€ ç³»ç»Ÿåˆå§‹åŒ–...</div>
        <div>âš ï¸ å¦‚æœé•¿æ—¶é—´æ— ååº”æˆ–å‡ºç°çº¢å­—ï¼Œè¯·æˆªå›¾å‘ç»™å¼€å‘è€…ã€‚</div>
        <hr style="border-color: #333; margin: 5px 0;">
    </div>

    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous" onload="log('Camera Utils åŠ è½½æˆåŠŸ', 'success')" onerror="log('Camera Utils åŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ç½‘ç»œ', 'error')"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous" onload="log('Control Utils åŠ è½½æˆåŠŸ', 'success')" onerror="log('Control Utils åŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ç½‘ç»œ', 'error')"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous" onload="log('Hands Core åŠ è½½æˆåŠŸ', 'success')" onerror="log('Hands Core åŠ è½½å¤±è´¥ï¼è¿™é€šå¸¸æ˜¯ CDN è¢«å¢™å¯¼è‡´çš„', 'error')"></script>

<script>
    // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
    window.addEventListener('load', () => {
        log('DOM å‡†å¤‡å°±ç»ªï¼Œå¼€å§‹åˆå§‹åŒ–é€»è¾‘...');
        
        // æ£€æŸ¥åº“æ˜¯å¦åŠ è½½
        if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
            log('âŒ è‡´å‘½é”™è¯¯ï¼šMediaPipe åº“æœªèƒ½åŠ è½½ã€‚è¯·å°è¯•æ›´æ¢ç½‘ç»œ (å¦‚åˆ‡æ¢ 4G/Wi-Fi) æˆ–ä½¿ç”¨ VPNã€‚', 'error');
            return;
        }

        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        canvasElement.width = canvasWidth;
        canvasElement.height = canvasHeight;

        // --- ç²’å­ä¸ç‰©ç†å‚æ•° ---
        const centerPoint = { x: canvasWidth / 2, y: canvasHeight / 2 };
        const MAX_PARTICLES = 600; 
        const MIN_DISTANCE_CONNECT = 80; 
        let currentForceFactor = 0.0; 
        let fingerTipPoint = null; 

        // --- ç²’å­ç±» ---
        class Particle {
            constructor() {
                this.resetPosition(true);
                this.size = Math.random() * 1.5 + 0.5; 
                this.color = Math.random() * 30 + 190; 
                this.alpha = 0.8; 
                this.friction = 0.96; 
                this.speedFactor = 1.5;
                this.BASE_FORCE = 0.005; 
            }
            update() {
                let dx = centerPoint.x - this.x;
                let dy = centerPoint.y - this.y;
                let distanceSq = dx * dx + dy * dy;
                let fieldForce = currentForceFactor * 1000000 / (distanceSq + 50000); 

                if (fingerTipPoint) {
                    let fdx = fingerTipPoint.x - this.x;
                    let fdy = fingerTipPoint.y - this.y;
                    let fDistanceSq = fdx * fdx + fdy * fdy;
                    const FINGER_ATTRACTION = 800000; 
                    let localForce = FINGER_ATTRACTION / (fDistanceSq + 20000); 
                    let fAngle = Math.atan2(fdy, fdx);
                    this.vx += localForce * Math.cos(fAngle);
                    this.vy += localForce * Math.sin(fAngle);
                }
                
                let randomForceX = (Math.random() - 0.5) * this.BASE_FORCE;
                let randomForceY = (Math.random() - 0.5) * this.BASE_FORCE;
                let angle = Math.atan2(dy, dx);
                this.vx += fieldForce * Math.cos(angle) + randomForceX;
                this.vy += fieldForce * Math.sin(angle) + randomForceY;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;

                if (this.x < -10 || this.x > canvasWidth + 10 || this.y < -10 || this.y > canvasHeight + 10) this.resetPosition();
            }
            resetPosition(isInitial = false) {
                const side = Math.floor(Math.random() * 4); 
                const speedFactor = this.speedFactor;
                if (side === 0) { this.x = Math.random() * canvasWidth; this.y = -10; } 
                else if (side === 1) { this.x = Math.random() * canvasWidth; this.y = canvasHeight + 10; } 
                else if (side === 2) { this.x = -10; this.y = Math.random() * canvasHeight; } 
                else { this.x = canvasWidth + 10; this.y = Math.random() * canvasHeight; }
                
                if (isInitial) {
                    this.vx = (Math.random() - 0.5) * speedFactor;
                    this.vy = (Math.random() - 0.5) * speedFactor;
                } else {
                    this.vx = (centerPoint.x - this.x) * 0.005 + (Math.random() - 0.5) * speedFactor;
                    this.vy = (centerPoint.y - this.y) * 0.005 + (Math.random() - 0.5) * speedFactor;
                }
            }
            draw() {
                canvasCtx.fillStyle = `hsla(${this.color}, 100%, 60%, ${this.alpha})`;
                canvasCtx.beginPath();
                canvasCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                canvasCtx.fill();
            }
        }

        let particlesArray = [];
        for (let i = 0; i < MAX_PARTICLES; i++) particlesArray.push(new Particle());

        function connectParticles() {
            let opacity = 1;
            for (let i = 0; i < particlesArray.length; i++) {
                for (let j = i; j < particlesArray.length; j++) {
                    let dx = particlesArray[i].x - particlesArray[j].x;
                    let dy = particlesArray[i].y - particlesArray[j].y;
                    let distanceSq = dx * dx + dy * dy;
                    if (distanceSq < MIN_DISTANCE_CONNECT * MIN_DISTANCE_CONNECT) {
                        opacity = 1 - (Math.sqrt(distanceSq) / MIN_DISTANCE_CONNECT);
                        canvasCtx.strokeStyle = `rgba(0, 200, 255, ${opacity * 0.4})`;
                        canvasCtx.lineWidth = 0.5;
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(particlesArray[i].x, particlesArray[i].y);
                        canvasCtx.lineTo(particlesArray[j].x, particlesArray[j].y);
                        canvasCtx.stroke();
                    }
                }
            }
        }

        // --- MediaPipe è®¾ç½® ---
        log('æ­£åœ¨é…ç½® MediaPipe Hands...');
        const hands = new Hands({locateFile: (file) => {
            log(`è¯·æ±‚åŠ è½½æ¨¡å‹æ–‡ä»¶: ${file}`);
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // æé€Ÿæ¨¡å¼
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        function detectGesture(landmarks) {
            let foldedFingers = 0;
            const TIP_INDEXES = [8, 12, 16, 20];
            const MCP_INDEXES = [5, 9, 13, 17];
            for (let i = 0; i < 4; i++) {
                if (landmarks[TIP_INDEXES[i]].y > landmarks[MCP_INDEXES[i]].y) foldedFingers++;
            }
            return foldedFingers >= 3 ? 'gather' : 'scatter';
        }

        function onResults(results) {
            // ç»˜åˆ¶é€»è¾‘
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            let targetFactor = 0.0; 
            fingerTipPoint = null;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                fingerTipPoint = { x: landmarks[8].x * canvasWidth, y: landmarks[8].y * canvasHeight };
                const gesture = detectGesture(landmarks);
                if (gesture === 'gather') targetFactor = 0.75; 
                else if (gesture === 'scatter') targetFactor = -1.5; 
            }

            currentForceFactor += (targetFactor - currentForceFactor) * 0.1;
            connectParticles();
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
                particlesArray[i].draw();
            }
        }

        // --- æ‘„åƒå¤´å¯åŠ¨é€»è¾‘ ---
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480,
            facingMode: 'user'
        });

        log('å°è¯•å¯åŠ¨æ‘„åƒå¤´...');
        camera.start()
            .then(() => {
                log('âœ… æ‘„åƒå¤´å¯åŠ¨æˆåŠŸï¼ç­‰å¾… AI æ¨¡å‹åŠ è½½...', 'success');
                // éšè—æ§åˆ¶å°ï¼Œåªç•™ä¸‹ä¸€è¡Œ
                document.getElementById('debug_console').style.maxHeight = '100px';
            })
            .catch(err => {
                log(`âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: ${err.message}`, 'error');
                log('æç¤º: è¯·ç¡®ä¿ä½¿ç”¨äº† HTTPS åè®® (å¦‚ Github Pages) ä¸”å·²æˆæƒæ‘„åƒå¤´ã€‚', 'error');
            });

        window.addEventListener('resize', () => {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvasElement.width = canvasWidth;
            canvasElement.height = canvasHeight;
            centerPoint.x = canvasWidth / 2;
            centerPoint.y = canvasHeight / 2;
        });
    });
</script>
</body>
</html>
