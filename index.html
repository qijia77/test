<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç§‘å¹»åŒæ§ç²’å­åœº (é£ŸæŒ‡è·Ÿéš)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #000; overflow: hidden; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center;}
        
        /* è§†é¢‘å…ƒç´ éšè— */
        #input_video { display: none; }
        
        /* Canvas è¦†ç›–å…¨å±ï¼Œä¸”æ°´å¹³é•œåƒç¿»è½¬ */
        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); 
            display: block;
        }

        .loading {
            position: absolute;
            color: rgba(0, 255, 255, 0.7); 
            font-family: 'Consolas', monospace;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 10;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="loading" id="loadingText">
        ğŸ‘‹ **ç²’å­åœºæ§åˆ¶**ï¼šæ­£åœ¨åŠ è½½æ¨¡å‹å’Œæ‘„åƒå¤´...<br>
        <hr style="margin: 10px 0; border-color: rgba(0, 255, 255, 0.3);">
        ğŸ‘‰ **é£ŸæŒ‡è·Ÿéš**ï¼šç²’å­ä¼šè¢«æ‚¨çš„é£ŸæŒ‡å¸å¼•ã€‚<br>
        âœŠ **æ¡ç´§æ‹³å¤´:** å…¨å±èšæ‹¢ | ğŸ’¡ **å¼ å¼€æ‰‹æŒ:** å…¨å±å‘æ•£
    </div>
    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingText = document.getElementById('loadingText');

    let canvasWidth = window.innerWidth;
    let canvasHeight = window.innerHeight;
    canvasElement.width = canvasWidth;
    canvasElement.height = canvasHeight;

    // --- å…¨å±€çŠ¶æ€å˜é‡ ---
    const centerPoint = { x: canvasWidth / 2, y: canvasHeight / 2 }; // å±å¹•ä¸­å¿ƒ
    let currentForceFactor = 0.0; 
    const BASE_FORCE = 0.005; 
    const MAX_PARTICLES = 1000; 
    
    let fingerTipPoint = null; // æ–°å¢ï¼šè¿½è¸ªé£ŸæŒ‡æŒ‡å°–çš„åæ ‡
    
    // --- ç²’å­ç±»å®šä¹‰ ---
    class Particle {
        constructor() {
            this.resetPosition(true); // é¦–æ¬¡è°ƒç”¨ï¼Œè®¾ç½®åˆå§‹é€Ÿåº¦
            this.size = Math.random() * 1.5 + 0.5; 
            this.color = Math.random() * 30 + 190; 
            this.alpha = 0.8; 
            this.friction = 0.96; // æ‘©æ“¦åŠ›å‡å°ï¼Œç²’å­è¿åŠ¨æ›´å¿«
        }

        update() {
            // 1. è®¡ç®—ä¸å±å¹•ä¸­å¿ƒè·ç¦» (ç”¨äºå®è§‚åœºåŠ›)
            let dx = centerPoint.x - this.x;
            let dy = centerPoint.y - this.y;
            let distanceSq = dx * dx + dy * dy;

            // 2. æ–½åŠ å®è§‚åœºåŠ› (ç”±æ‰‹åŠ¿æ§åˆ¶)
            let fieldForce = currentForceFactor * 1000000 / (distanceSq + 50000); 

            // 3. æ–½åŠ å±€éƒ¨å¸å¼•åŠ› (å•æŒ‡è·Ÿéšæ•ˆæœ)
            if (fingerTipPoint) {
                let fdx = fingerTipPoint.x - this.x;
                let fdy = fingerTipPoint.y - this.y;
                let fDistanceSq = fdx * fdx + fdy * fdy;
                
                // å±€éƒ¨å¸å¼•åŠ›å¼ºåº¦ (å¸¸æ•°å¸å¼•åŠ›)
                const FINGER_ATTRACTION = 800000; 
                let localForce = FINGER_ATTRACTION / (fDistanceSq + 20000); 

                // åº”ç”¨å±€éƒ¨å¸å¼•åŠ›
                let fAngle = Math.atan2(fdy, fdx);
                this.vx += localForce * Math.cos(fAngle);
                this.vy += localForce * Math.sin(fAngle);
            }
            
            // 4. æ–½åŠ éšæœºå¾®å¼±åŠ›
            let randomForceX = (Math.random() - 0.5) * BASE_FORCE;
            let randomForceY = (Math.random() - 0.5) * BASE_FORCE;

            // åº”ç”¨å®è§‚åœºåŠ›å’ŒéšæœºåŠ›
            let angle = Math.atan2(dy, dx);
            this.vx += fieldForce * Math.cos(angle) + randomForceX;
            this.vy += fieldForce * Math.sin(angle) + randomForceY;
            
            // 5. åº”ç”¨é€Ÿåº¦å’Œæ‘©æ“¦åŠ›
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= this.friction;
            this.vy *= this.friction;

            // 6. è¾¹ç•Œå¾ªç¯
            if (this.x < -10 || this.x > canvasWidth + 10 || this.y < -10 || this.y > canvasHeight + 10) {
                 this.resetPosition();
            }
        }
        
        // é‡ç½®ä½ç½®åˆ°å¤–è¾¹ç¼˜ï¼Œå¹¶èµ‹äºˆä¸€ä¸ªå¾®å¼±çš„æœå‘ä¸­å¿ƒçš„é€Ÿåº¦
        resetPosition(isInitial = false) {
            const side = Math.floor(Math.random() * 4); 
            const speedFactor = 1.5; // ç²’å­ç§»åŠ¨é€Ÿåº¦çš„å…³é”®å‚æ•°

            if (side === 0) { // ä¸Šæ–¹ (Y < 0)
                this.x = Math.random() * canvasWidth;
                this.y = -10;
            } else if (side === 1) { // ä¸‹æ–¹ (Y > H)
                this.x = Math.random() * canvasWidth;
                this.y = canvasHeight + 10;
            } else if (side === 2) { // å·¦æ–¹ (X < 0)
                this.x = -10;
                this.y = Math.random() * canvasHeight;
            } else { // å³æ–¹ (X > W)
                this.x = canvasWidth + 10;
                this.y = Math.random() * canvasHeight;
            }
            
            if (isInitial) {
                this.vx = (Math.random() - 0.5) * speedFactor;
                this.vy = (Math.random() - 0.5) * speedFactor;
            } else {
                // é‡ç½®æ—¶ï¼Œç»™äºˆä¸€ä¸ªæœå‘ä¸­å¿ƒçš„åˆå§‹æ¨åŠ›
                this.vx = (centerPoint.x - this.x) * 0.005 + (Math.random() - 0.5) * speedFactor;
                this.vy = (centerPoint.y - this.y) * 0.005 + (Math.random() - 0.5) * speedFactor;
            }
        }

        draw() {
            canvasCtx.fillStyle = `hsla(${this.color}, 100%, 60%, ${this.alpha})`;
            canvasCtx.beginPath();
            canvasCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            canvasCtx.fill();
        }
    }

    // åˆå§‹åŒ–ç²’å­æ± 
    let particlesArray = [];
    function initParticles() {
        for (let i = 0; i < MAX_PARTICLES; i++) {
            particlesArray.push(new Particle());
        }
    }
    initParticles();

    // --- MediaPipe/æ‘„åƒå¤´è®¾ç½® (ä»…ç”¨äºæ‰‹åŠ¿è¯†åˆ«) ---
    const HANDS_URL = "https://cdn.jsdelivr.net/npm/@mediapipe/hands";
    
    const hands = new Hands({locateFile: (file) => {
        return `${HANDS_URL}/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1, 
        modelComplexity: 0, 
        minDetectionConfidence: 0.5, 
        minTrackingConfidence: 0.5
    });

    // ä¼˜åŒ–åçš„æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
    function detectGesture(landmarks) {
        let foldedFingers = 0;
        const TIP_INDEXES = [8, 12, 16, 20];
        const MCP_INDEXES = [5, 9, 13, 17];
        
        for (let i = 0; i < 4; i++) {
            if (landmarks[TIP_INDEXES[i]].y > landmarks[MCP_INDEXES[i]].y) {
                foldedFingers++;
            }
        }

        if (foldedFingers >= 3) {
            return 'gather';
        } 
        return 'scatter';
    }


    // MediaPipe ç»“æœå›è°ƒå‡½æ•°
    function onResults(results) {
        // 1. æ¸…é™¤èƒŒæ™¯ (å¢åŠ å¾®å¼±æ‹–å°¾)
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);
        
        // 2. æ›´æ–°å®è§‚åœºåŠ›å’Œé£ŸæŒ‡åæ ‡
        let targetFactor = 0.0; 
        fingerTipPoint = null;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            loadingText.style.display = 'none'; 
            const landmarks = results.multiHandLandmarks[0];

            // æ•è·é£ŸæŒ‡æŒ‡å°–åæ ‡ (Index 8)
            fingerTipPoint = {
                x: landmarks[8].x * canvasWidth,
                y: landmarks[8].y * canvasHeight
            };

            const gesture = detectGesture(landmarks);
            
            if (gesture === 'gather') {
                targetFactor = 0.75; // å¼ºå¼•åŠ›
            } else if (gesture === 'scatter') {
                targetFactor = -1.5; // å¼ºæ–¥åŠ›
            }
        } else {
             // å¦‚æœæ‰‹éƒ¨æ¶ˆå¤±ï¼ŒåŠ›æ…¢é€Ÿå½’é›¶ï¼Œæç¤ºæ–‡å­—æ˜¾ç¤º
             targetFactor = 0.0;
             loadingText.style.display = 'block'; 
        }

        // å¹³æ»‘è¿‡æ¸¡å½“å‰åŠ›
        currentForceFactor += (targetFactor - currentForceFactor) * 0.1;
        
        // 3. ç»˜åˆ¶ç²’å­
        for (let i = 0; i < particlesArray.length; i++) {
            particlesArray[i].update();
            particlesArray[i].draw();
        }
        
        // 4. å¾ªç¯
        requestAnimationFrame(() => hands.send({image: videoElement}));
    }

    // --- å¯åŠ¨æ‘„åƒå¤´ ---
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement}); 
        },
        width: 640, 
        height: 480,
        facingMode: 'user'
    });
    camera.start().catch(err => {
        loadingText.innerHTML = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™å’Œ HTTPS ç¯å¢ƒã€‚";
        console.error(err);
    });

    // çª—å£å¤§å°æ”¹å˜é€‚åº”
    window.addEventListener('resize', () => {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        canvasElement.width = canvasWidth;
        canvasElement.height = canvasHeight;
        centerPoint.x = canvasWidth / 2;
        centerPoint.y = canvasHeight / 2;
    });

</script>
</body>
</html>
