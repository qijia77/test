<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç§‘å¹»ç­‰ç¦»å­ä½“ç²’å­åœº (å…¨å±æ§åˆ¶)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #000; overflow: hidden; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center;}
        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            display: block;
        }

        .loading {
            position: absolute;
            color: rgba(0, 255, 255, 0.7); /* é’è‰²æç¤º */
            font-family: 'Consolas', monospace;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 10;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="loading" id="loadingText">
        ğŸ‘‹ **ç²’å­åœºæ§åˆ¶**ï¼šè¯·è¿æ¥æ‘„åƒå¤´...<br>
        <hr style="margin: 10px 0; border-color: rgba(0, 255, 255, 0.3);">
        ğŸ’¡ **å¼ å¼€æ‰‹æŒ:** å…¨å±å‘æ•£ (æ–¥åŠ›å¢å¼º)<br>
        âœŠ **æ¡ç´§æ‹³å¤´:** å…¨å±èšæ‹¢ (å¼•åŠ›å¢å¼º)
    </div>
    <video id="input_video" style="display: none;"></video>
    <canvas id="output_canvas"></canvas>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingText = document.getElementById('loadingText');

    let canvasWidth = window.innerWidth;
    let canvasHeight = window.innerHeight;
    canvasElement.width = canvasWidth;
    canvasElement.height = canvasHeight;

    // --- å…¨å±€çŠ¶æ€å˜é‡ ---
    const centerPoint = { x: canvasWidth / 2, y: canvasHeight / 2 }; // å±å¹•ä¸­å¿ƒ
    let currentForceFactor = 0.0; // å½“å‰ä½œç”¨åŠ›çš„å¼ºåº¦ (è´Ÿå€¼=æ–¥åŠ›, æ­£å€¼=å¼•åŠ›)
    const BASE_FORCE = 0.005; // åŸºç¡€éšæœºåŠ›
    const MAX_PARTICLES = 1000; // ç²’å­æ•°é‡ï¼Œå¢å¼ºç§‘å¹»å¯†åº¦
    
    // --- ç²’å­ç±»å®šä¹‰ ---
    class Particle {
        constructor() {
            // åˆå§‹ä½ç½®éšæœºåˆ†å¸ƒ
            this.x = Math.random() * canvasWidth;
            this.y = Math.random() * canvasHeight;
            this.vx = (Math.random() - 0.5) * 0.5; // åŸºç¡€é€Ÿåº¦æ›´æ…¢ï¼Œå¢åŠ æ¼‚æµ®æ„Ÿ
            this.vy = (Math.random() - 0.5) * 0.5;
            this.size = Math.random() * 1.5 + 0.5; // ç²’å­æ›´å°ï¼Œå¯†åº¦æ›´å¤§
            this.color = Math.random() * 30 + 190; // é¢œè‰²é™åˆ¶åœ¨è“è‰²åˆ°é’è‰²èŒƒå›´ (190-220)
            this.alpha = 0.8; // åŸºç¡€é€æ˜åº¦
            this.friction = 0.985; 
        }

        update() {
            // 1. è®¡ç®—ä¸å±å¹•ä¸­å¿ƒè·ç¦»
            let dx = centerPoint.x - this.x;
            let dy = centerPoint.y - this.y;
            let distanceSq = dx * dx + dy * dy;

            // 2. æ–½åŠ å®è§‚åœºåŠ› (ç”±æ‰‹åŠ¿æ§åˆ¶)
            let fieldForce = currentForceFactor * 1000000 / (distanceSq + 50000); // è·ç¦»å¹³æ–¹çš„åæ¯”åŠ›

            // 3. æ–½åŠ éšæœºå¾®å¼±åŠ› (å¢åŠ æ•°æ®æµåŠ¨çš„éšæœºæ€§)
            let randomForceX = (Math.random() - 0.5) * BASE_FORCE;
            let randomForceY = (Math.random() - 0.5) * BASE_FORCE;

            // åº”ç”¨åŠ›
            let angle = Math.atan2(dy, dx);
            this.vx += fieldForce * Math.cos(angle) + randomForceX;
            this.vy += fieldForce * Math.sin(angle) + randomForceY;
            
            // åº”ç”¨é€Ÿåº¦å’Œæ‘©æ“¦åŠ›
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= this.friction;
            this.vy *= this.friction;

            // 4. è¾¹ç•Œå¾ªç¯
            if (this.x < 0 || this.x > canvasWidth || this.y < 0 || this.y > canvasHeight) {
                 this.resetPosition();
            }
        }
        
        resetPosition() {
             this.x = Math.random() * canvasWidth;
             this.y = Math.random() * canvasHeight;
             this.vx = (Math.random() - 0.5) * 0.5;
             this.vy = (Math.random() - 0.5) * 0.5;
        }

        draw() {
            // HSL é¢œè‰²ï¼Œé’è‰²ä¸ºä¸»ï¼Œé¥±å’Œåº¦é«˜
            canvasCtx.fillStyle = `hsla(${this.color}, 100%, 60%, ${this.alpha})`;
            canvasCtx.beginPath();
            canvasCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            canvasCtx.fill();
        }
    }

    // åˆå§‹åŒ–ç²’å­æ± 
    let particlesArray = [];
    function initParticles() {
        for (let i = 0; i < MAX_PARTICLES; i++) {
            particlesArray.push(new Particle());
        }
    }
    initParticles();

    // --- MediaPipe/æ‘„åƒå¤´è®¾ç½® (ä»…ç”¨äºæ‰‹åŠ¿è¯†åˆ«) ---
    // æ­¤å¤„é‡æ–°å¼•å…¥ MediaPipe Hands åº“ï¼Œåªç”¨äºæ‰‹åŠ¿åˆ¤æ–­ï¼Œä¸ç”¨äºç²’å­åæ ‡
    const HANDS_URL = "https://cdn.jsdelivr.net/npm/@mediapipe/hands";
    
    // ç¡®ä¿ MediaPipe Hands åº“è¢«åŠ è½½ï¼ˆæ­¤æ­¥éª¤ä¾èµ–ç½‘ç»œï¼‰
    const hands = new Hands({locateFile: (file) => {
        return `${HANDS_URL}/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1, 
        modelComplexity: 0, 
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    // ä¼˜åŒ–åçš„æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
    function detectGesture(landmarks) {
        // å…³é”®ç‚¹ç´¢å¼•ï¼š5, 9, 13, 17 æ˜¯æŒ‡æ ¹ (MCP); 8, 12, 16, 20 æ˜¯æŒ‡å°– (TIP)
        let foldedFingers = 0;
        const TIP_INDEXES = [8, 12, 16, 20];
        const MCP_INDEXES = [5, 9, 13, 17];
        
        for (let i = 0; i < 4; i++) {
            // å¦‚æœæŒ‡å°–çš„ Y åæ ‡ > æŒ‡æ ¹çš„ Y åæ ‡ï¼Œè¯´æ˜æŒ‡å°–å‘ä¸‹å¼¯æ›²ï¼ˆæ¡æ‹³ï¼‰
            if (landmarks[TIP_INDEXES[i]].y > landmarks[MCP_INDEXES[i]].y) {
                foldedFingers++;
            }
        }

        // æ¡æ‹³ (èšæ‹¢)ï¼š3 æ ¹æˆ–ä»¥ä¸Šå¼¯æ›²
        if (foldedFingers >= 3) {
            return 'gather';
        } 
        
        // å¼ æ‰‹ (å‘æ•£)ï¼šå¦åˆ™è®¤ä¸ºæ˜¯å¼ æ‰‹
        return 'scatter';
    }


    // MediaPipe ç»“æœå›è°ƒå‡½æ•°
    function onResults(results) {
        // 1. æ¸…é™¤èƒŒæ™¯ (å¢åŠ å¾®å¼±æ‹–å°¾ï¼Œè®©ç²’å­çœ‹èµ·æ¥åƒå…‰æŸ)
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);
        
        // 2. æ›´æ–°å®è§‚åœºåŠ› (æ ¸å¿ƒé€»è¾‘)
        let targetFactor = 0.0; // é»˜è®¤ä¸­æ€§

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            loadingText.style.display = 'none'; // éšè—åŠ è½½æç¤º
            const gesture = detectGesture(results.multiHandLandmarks[0]);
            
            if (gesture === 'gather') {
                targetFactor = 0.3; // å¼ºå¼•åŠ›ï¼Œå‘ä¸­å¿ƒèšæ‹¢
            } else if (gesture === 'scatter') {
                targetFactor = -0.6; // å¼ºæ–¥åŠ›ï¼Œå‘å¤–çˆ†ç‚¸ (æ–¥åŠ›è¦æ›´å¼º)
            }
        } else {
             // æ…¢é€Ÿæ¢å¤æç¤º
             loadingText.style.display = 'block'; 
        }

        // å¹³æ»‘è¿‡æ¸¡å½“å‰åŠ›
        currentForceFactor += (targetFactor - currentForceFactor) * 0.1;
        
        // 3. ç»˜åˆ¶ç²’å­
        for (let i = 0; i < particlesArray.length; i++) {
            particlesArray[i].update();
            particlesArray[i].draw();
        }
        
        // 4. å¾ªç¯
        requestAnimationFrame(() => hands.send({image: videoElement}));
    }

    // --- å¯åŠ¨æ‘„åƒå¤´ ---
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            // ç¬¬ä¸€æ¬¡è°ƒç”¨åœ¨ onResults é‡Œé¢é€’å½’
            await hands.send({image: videoElement}); 
        },
        width: 640, 
        height: 480,
        facingMode: 'user'
    });
    camera.start().catch(err => {
        loadingText.innerHTML = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™å’Œ HTTPS ç¯å¢ƒã€‚";
        console.error(err);
    });

    // çª—å£å¤§å°æ”¹å˜é€‚åº”
    window.addEventListener('resize', () => {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        canvasElement.width = canvasWidth;
        canvasElement.height = canvasHeight;
        centerPoint.x = canvasWidth / 2;
        centerPoint.y = canvasHeight / 2;
    });

</script>
</body>
</html>
